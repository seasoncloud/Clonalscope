#' Creating Finer Segments based on 1st Round Clonalscope Clusters
#' 
#' This function creates new CNV segments list based on the 1st round estimation with
#' chromosomal arms segments for no WGS case.
#' 
#' @param mtx A (sparse) matrix with each row being a feature and each column being a cell barcode. (Output from cellranger)
#' @param barcodes A matrix/ data.frame with barcodes for each cell in the first column.
#' @param features A matrix/data.frame with the columns- 1st: gendID; 2nd: gene name. Each row is a feature whose order should correspond to the rows of "mtx".
#' @param Cov_obj Clonalscope 1st round estimation results with chromosomal arms (no paired WGS).
#' @param Zest Clonaslcope clustering results. Setting to NULL(default) will lead to directly using Cov_obj's saved clustering results.
#' @param bin_bed A bed file for assembly with the chromosome, start and end of bins.
#' @param celltype0 A matrix with two columns: COL1- cell barcodes; COL2- cell types (Tumor cells should be labeled as "tumor" and the set of cells used as control should be labeled as "normal").
#' @param gtf A standard gene annotation file for the corresponding genome assembly.
#' @param dir_path A path for saving the objects and plots.
#' @param plot_seg Logical (TRUE/ FALSE). Whether or not to plot the HMM segmentation result.
#' @param hmm_states An ordered vector for the HMM numeric states (deletion, 1-copy gain, 2-copy gains).
#' @param hmm_sd Numeric. Fixed standard deviation for the HMM states.
#' @param hmm_p Numeric. Transition probability for the HMM algorithm.
#' @param nmean Integer. Width of moving window for runmean.
#' @param adj Numeric. Value for tumor coverage adjustment.
#' @param rds_path The path for saving the rds files for the estimated results for each region.
#' @param max_qt Numeric value in [0,1]. Setting the maximum value to the max_qt quantile to avoid extreme values.
#' @param merge Whether to merge segments with similar profile or not
#' @param assay Assay of bulk segmentation.
#'
#' @return "seg_filtered": A segment table containing chromosome, start and end of each segment.
#' New CNV segments generated by merging breakpoints from different clusters.
#' 
#' @import data.table
#' @export
CreateSegtableNoWGS=function(mtx=NULL, barcodes=NULL, features=NULL, Cov_obj=NULL,Zest=NULL,
                             bin_bed=NULL, celltype0=NULL,dir_path=NULL,bin_mtx=NULL,gtf=NULL,size=NULL,
                             plot_seg = TRUE, hmm_states = c(0.5, 1, 1.5, 2), max_qt = 0.95, nmean=500, rm_extreme = 2, adj=-0.5, 
                             rds_path=NULL,merge=F,assay="WGS"){

  # align cells as in the celltype annotation
  mtx=mtx[,match(celltype0[,1], barcodes$V1)]
  barcodes=barcodes[match(celltype0[,1], barcodes$V1),, drop=F]

  # retrive Clonalscope clustering results
  if(is.null(Zest)){
    clustering= Cov_obj$result_final$clustering
    clustering2= Cov_obj$result_final$clustering2
    result=Cov_obj$result_final$result
    Zest=result$Zest
  }
  # check gene annotation file
  if(is.null(gtf)){
    message("Gene annotation file is empty, please provide the gene annotation file!")
  }

  # generate bin x cell count matrix based on the bin bed file
  if(is.null(bin_mtx)){
    bin_mtx=Gen_bin_cell_rna_filtered(bin_bed=bin_bed, barcodes=barcodes, gene_matrix=mtx,
                                      genes=features,gtf=gtf)
    bin_mtx=as.matrix(bin_mtx)
    saveRDS(bin_mtx,paste0(dir_path,"/","bin_mtx.rds"))
  }

  # convert the bin x cell count matrix to bin x cluster count matrix
  # the cluster comes from 1st round noWGS estimation with chromosomal arms
  bin_by_cluster=matrix(nrow=nrow(bin_mtx), ncol=length(table(Zest)))
  #print(dim(bin_by_cluster))
  for(ii in 1:length(table(Zest))){
    sub=bin_mtx[,which(Zest==names(table(Zest))[ii]),drop=F]
    sub=as.matrix(sub)
    bin_by_cluster[,ii]=rowSums(sub)
    #print(ii)
  }
  colnames(bin_by_cluster)=paste0('C', names(table(Zest)))
  print(paste0("Bin x Cluster matrix generated, with dimension of ",dim(bin_by_cluster)[1]," bins x ",dim(bin_by_cluster)[2],"clusters"))
  #return(bin_by_cluster)
  
  ## HMM segmentation based on the bin-by-cluster matrix
  Obj_all=list()
  for(cc in 1:ncol(bin_by_cluster)){ # for each cluster, perform HMM tp obtain segments
    raw_counts=bin_by_cluster[,cc, drop=F]
    rownames(raw_counts)=c(paste0(bin_bed[,1], "-", as.numeric(bin_bed[,2])+1, "-", bin_bed[,3]))
          
    ref_counts=t(t(rowSums(bin_mtx[,which(celltype0[,2]=='normal'),drop=F])))
    rownames(ref_counts)=c(paste0(bin_bed[,1], "-", bin_bed[,2], "-", bin_bed[,3]))

    name=paste0(colnames(bin_by_cluster)[cc]) # cluster name
    hmm_name = paste0(name,"_qt",max_qt*100,"_rm",rm_extreme,"_nmean",nmean)
    Obj_filtered=Createobj_bulk(raw_counts=raw_counts , ref_counts=ref_counts ,
                                samplename=hmm_name, genome_assembly="GRCh38", dir_path=dir_path, size=size, assay='WGS')

    # need self adjustment, user could consider adjusting these parameters after observing output figures
    Obj_filtered=Segmentation_bulk(Obj_filtered=Obj_filtered,
                                   plot_seg=plot_seg, hmm_states = hmm_states, 
                                   max_qt=max_qt, nmean=nmean, rm_extreme=rm_extreme, adj=adj,rds_path=rds_path,assay=assay)
    seg_table=Obj_filtered$seg_table

    # save each cluster's segments
    clust_list=list()
    clust_list$seg_table=seg_table
    clust_list$annot=Obj_filtered$annot

    Obj_all[[name]]=clust_list
    print(name)
  }
  saveRDS(Obj_all,paste0(dir_path,"/","Obj_all_cluster.rds" ))

  # merge segment table from clusters
  seg_all=NULL
  for(ii in names(Obj_all)){
    seg_all=rbind(seg_all, Obj_all[[ii]][['seg_table']])
    print(ii)
  }
  seg_all=seg_all[order(as.numeric(seg_all$chr),as.numeric(seg_all$start)),,drop=F]
  tmp=paste0(seg_all$chr,"-", seg_all$start, "-",seg_all$end)
  seg_all=seg_all[!duplicated(tmp),,drop=F]

  seg_filtered=NULL
  for(chr in 1:22){
    sub=seg_all[which(seg_all$chr==chr),, drop=F]
    bp=sort(unique(as.numeric(c(sub$start, sub$end))))
    seg_cbn=cbind(rep(sub[1,1], (length(bp)-1)), bp[1:(length(bp)-1)], bp[2:length(bp)]) # unique breakpoints

    seg_cbn = cbind(seg_cbn,rep(NA,length(bp)-1)) # initialize state
    # find segment state
    subject=GRanges(seqnames = sub$chr, ranges=IRanges(as.numeric(sub$start), as.numeric(sub$end)-1))
    query=GRanges(seqnames = seg_cbn[,1], ranges=IRanges(as.numeric(seg_cbn[,2]), as.numeric(seg_cbn[,3])-1))
    cov = countOverlaps(query, subject)
    fov = as.matrix(findOverlaps(query, subject))
    # summarize states
    for(i in 1:(length(bp)-1)){
      seg_cbn[i,4]=paste(sort(as.numeric(unique(sub[fov[fov[,1] == i,2],'states']))),collapse=" ")
    }
    if(merge == T){
      # merge segments with same occuring copy states
      start_idx = 1
      end_idx=1
      new_seg_cbn = c()
      for(i in 1:(dim(seg_cbn)[1])){
        if(!(i+1 >dim(seg_cbn)[1])){
          if((seg_cbn[i,4] ==seg_cbn[i+1,4])){ # same copy number state)
            end_idx = end_idx + 1
          }else{ # switching copy number state
            new_seg_cbn = rbind(new_seg_cbn,c(chr,seg_cbn[start_idx,2],seg_cbn[end_idx,3],seg_cbn[end_idx,4]))
            # update start and end idx
            start_idx = i+1
            end_idx = i+1
          }
        }else{ # end of the segments
          new_seg_cbn = rbind(new_seg_cbn,c(chr,seg_cbn[start_idx,2],seg_cbn[end_idx,3],seg_cbn[end_idx,4]))
          if(end_idx<i){ # previous segments not equal to last segment, write out last segment
            new_seg_cbn = rbind(new_seg_cbn,c(chr,seg_cbn[i,2],seg_cbn[i,3],seg_cbn[i,4]))
          }
        }
      }
      seg_cbn = new_seg_cbn
    }
    # append the chromosome segments
    seg_filtered=rbind(seg_filtered, seg_cbn)
    #print(chr)
  
  }
  saveRDS(seg_filtered,paste0(dir_path,"seg_filtered_from_cluster.rds"))

  return(seg_filtered)
}
